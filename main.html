<!DOCTYPE html>
<html lang="uz">
<head>
  <meta charset="UTF-8">
  <title>Edit chek</title>
  <style>
    @font-face {
      font-family: 'MyFont';
      src: url('font.ttf');
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    #canvas {
      width: 100vw;
      height: 100vh;
      position: relative;
      font-family: 'MyFont', sans-serif;
    }

    #bgVideo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: -1;
    }

    .text {
      position: absolute;
      color: white;
      font-size: 74px;
      cursor: move;
      user-select: none;
      white-space: nowrap;
      transform-origin: center center;
      touch-action: none;
    }

    input {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px;
      font-size: 18px;
      z-index: 10;
    }
  </style>
</head>
<body>

  <video id="bgVideo" src="orqa.mp4" autoplay muted loop playsinline></video>

  <div id="canvas"></div>
  <input type="text" id="textInput" placeholder="Enter balance Text" />

  <script>
    const canvas = document.getElementById('canvas');
    const input = document.getElementById('textInput');
    let clickCount = 0;
    let clickTimer;

    canvas.addEventListener('click', (e) => {
      clickCount++;
      if (clickCount >= 4) {
        document.querySelectorAll('.text').forEach(el => el.remove());
        clickCount = 0;
        return;
      }

      clearTimeout(clickTimer);
      clickTimer = setTimeout(() => { clickCount = 0 }, 1000);

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      input.dataset.x = x;
      input.dataset.y = y;

      input.style.display = 'block';
      input.focus();
      input.value = '';
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && input.value.trim() !== '') {
        const textDiv = document.createElement('div');
        textDiv.className = 'text';
        textDiv.style.left = input.dataset.x + 'px';
        textDiv.style.top = input.dataset.y + 'px';
        textDiv.innerText = input.value;
        textDiv.dataset.scale = "1";
        makeInteractive(textDiv);
        canvas.appendChild(textDiv);

        input.style.display = 'none';
        input.value = '';
      }
    });

    function makeInteractive(el) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;
      let pinchStartDist = 0;
      let startScale = 1;

      el.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(el.style.left);
        startTop = parseInt(el.style.top);
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          el.style.left = (startLeft + dx) + 'px';
          el.style.top = (startTop + dy) + 'px';
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      el.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
          isDragging = true;
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          startLeft = parseInt(el.style.left);
          startTop = parseInt(el.style.top);
        } else if (e.touches.length === 2) {
          pinchStartDist = getDistance(e.touches[0], e.touches[1]);
          startScale = parseFloat(el.dataset.scale || "1");
        }
      });

      el.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && isDragging) {
          const dx = e.touches[0].clientX - startX;
          const dy = e.touches[0].clientY - startY;
          el.style.left = (startLeft + dx) + 'px';
          el.style.top = (startTop + dy) + 'px';
        } else if (e.touches.length === 2) {
          const newDist = getDistance(e.touches[0], e.touches[1]);
          const scale = startScale * (newDist / pinchStartDist);
          el.style.transform = `scale(${scale})`;
          el.dataset.scale = scale.toFixed(2);
        }
      });

      el.addEventListener('touchend', () => {
        isDragging = false;
      });
    }

    function getDistance(a, b) {
      const dx = b.clientX - a.clientX;
      const dy = b.clientY - a.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
  </script>

</body>
</html>